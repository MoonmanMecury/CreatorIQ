

# PROMPT: Data Fusion, Scoring Engine & Unified Insights Layer — CreatorIQ Step 2

---

## PROJECT CONTEXT

You are continuing development of **CreatorIQ**, a SaaS web application that helps creators, marketers, and agencies discover high-opportunity content niches using real data.

**Stack:**
- Next.js 14 (App Router), TypeScript, Tailwind CSS, shadcn/ui, React Query
- ASP.NET Core REST API backend (already built)
- PostgreSQL database
- JWT authentication

**What is already complete:**
- YouTube Data API v3 integration (video metadata, channel stats, engagement data)
- Google Trends via Pytrends integration (interest over time, regional interest, related queries)
- Data Normalization Layer (Step 1) — produces `demand_score`, `growth_score`, `supply_score`, `engagement_score`, `regional_strength` as 0–100 values per topic
- Modular service architecture on the backend
- Dark-mode-first analytics dashboard UI shell

**What you are building now:** The **Data Fusion & Opportunity Scoring Layer** — the engine that combines all normalized signals into a single actionable intelligence object that answers one question: *"Is this niche worth entering right now?"*

---

## DELIVERABLES — BUILD ALL OF THE FOLLOWING

---

### 1. TypeScript Type Definitions

**File:** `/features/insights/types.ts`

Define and export all of the following interfaces. Do not skip any field. Add JSDoc comments explaining what each field represents.

```ts
export interface TrendSignal {
  keyword: string
  velocity: number          // rate of change in interest over time
  growthRate: number        // % growth over the measurement window
  regionalStrength: number  // geographic concentration score 0-100
  risingQueriesCount: number // number of breakout related queries detected
}

export interface CreatorSignal {
  keyword: string
  videoCount: number         // total YouTube videos for this keyword
  avgViews: number           // average views per video in top results
  avgEngagement: number      // avg (likes+comments)/views ratio as 0-100
  topChannelSubs: number     // subscriber count of the dominant channel
  uploadFrequency: number    // avg uploads per week across top channels
  smallCreatorRatio: number  // % of top videos from channels < 100k subs
}

export interface OpportunityScore {
  keyword: string
  demandScore: number        // 0-100
  competitionScore: number   // 0-100 (higher = more competition)
  saturationScore: number    // 0-100 (higher = more saturated)
  opportunityScore: number   // 0-100 final composite score
  verdict: 'LOW' | 'MEDIUM' | 'HIGH' | 'GOLDMINE'
  signals: {
    trend: TrendSignal
    creator: CreatorSignal
  }
  insights: string[]         // human-readable bullet point insights, e.g. "Dominated by small creators"
  computedAt: string         // ISO timestamp
}

export interface InsightsResponse {
  keyword: string
  opportunityScore: number
  verdict: 'LOW' | 'MEDIUM' | 'HIGH' | 'GOLDMINE'
  demandScore: number
  competitionScore: number
  saturationScore: number
  signals: {
    trend: TrendSignal
    creator: CreatorSignal
  }
  insights: string[]
  computedAt: string
}
```

---

### 2. Scoring Engine

**File:** `/features/insights/scoring.ts`

Implement the following functions. Each must be a **pure function** — no side effects, no API calls, fully deterministic.

#### `calculateDemandScore(trend: TrendSignal): number`
Weighted composite of:
- Trend velocity → 40% weight
- Growth rate (normalized 0-100) → 30% weight
- Regional strength → 20% weight
- Rising queries count (normalized: 0 queries = 0, 10+ queries = 100) → 10% weight

Return clamped 0–100.

#### `calculateCompetitionScore(creator: CreatorSignal): number`
Weighted composite of:
- Video count (log-normalized, 10M videos = 100) → 35% weight
- Top channel subscriber count (log-normalized, 10M subs = 100) → 30% weight
- Upload frequency (normalized: 0 uploads/week = 0, 20+/week = 100) → 20% weight
- Small creator ratio inverted (high small creator ratio = low competition) → 15% weight

Return clamped 0–100.

#### `calculateSaturationScore(trend: TrendSignal, creator: CreatorSignal): number`
Measures how crowded the niche is. High saturation = many established creators with high views + low differentiation opportunity.

Weighted composite of:
- Avg views per video (log-normalized, 10M avg views = 100) → 30% weight
- Video count score (reuse from competition) → 25% weight
- Top channel subs score (reuse from competition) → 25% weight
- Small creator ratio inverted → 20% weight

Return clamped 0–100.

#### `calculateOpportunityScore(demand: number, competition: number, saturation: number): number`
Formula:
```
opportunity = demand * (1 - competition/100) * (1 - saturation/100)
```
Normalize result to 0–100 and clamp. Round to 1 decimal place.

#### `getVerdict(opportunityScore: number): 'LOW' | 'MEDIUM' | 'HIGH' | 'GOLDMINE'`
- 0–25 → `'LOW'`
- 26–50 → `'MEDIUM'`
- 51–75 → `'HIGH'`
- 76–100 → `'GOLDMINE'`

#### `generateInsights(trend: TrendSignal, creator: CreatorSignal, scores: { demand: number, competition: number, saturation: number, opportunity: number }): string[]`
Return an array of 3–6 human-readable insight strings based on the data. Use conditional logic to generate relevant insights. Examples of the kinds of strings to generate:
- `"High demand with low competition — strong entry window"`
- `"Dominated by small creators — barrier to entry is low"`
- `"Fast-rising keyword cluster detected"`
- `"Strong regional growth in specific markets"`
- `"Niche is oversaturated — differentiation required"`
- `"Upload frequency is low — consistent posting could dominate"`

Generate insights dynamically based on actual score thresholds, not hardcoded strings.

---

### 3. Aggregation Service

**File:** `/features/insights/services/generateInsights.ts`

Create and export a `generateInsights(keyword: string): Promise<InsightsResponse>` function.

Responsibilities in order:
1. Fetch trend data from your existing `/api/trends` endpoint (or simulate with realistic mock data if endpoint isn't ready — clearly comment which)
2. Fetch YouTube data from your existing `/api/youtube` endpoint (or simulate similarly)
3. Map raw API responses into `TrendSignal` and `CreatorSignal` shapes
4. Call each scoring function from `scoring.ts`
5. Call `generateInsights()` to produce insight bullets
6. Assemble and return the full `InsightsResponse` object

For simulated data, use realistic variance — do not use the same static values for every keyword. Seed variance based on the keyword string so results are deterministic per keyword (e.g., use a simple hash of the keyword string to offset base values).

---

### 4. API Route

**File:** `/app/api/insights/route.ts`

Create a `GET` handler that:
- Accepts query param `keyword` (required — return 400 if missing)
- Calls `generateInsights(keyword)`
- Returns the full `InsightsResponse` as JSON
- Adds a simulated 600ms delay (to demonstrate loading states in UI)
- Returns 500 with a structured error object on failure

Example request/response:

```
GET /api/insights?keyword=ai+tools

Response 200:
{
  "keyword": "ai tools",
  "opportunityScore": 82,
  "verdict": "GOLDMINE",
  "demandScore": 91,
  "competitionScore": 38,
  "saturationScore": 27,
  "signals": { ... },
  "insights": [
    "High demand with low competition — strong entry window",
    "Fast-rising keyword cluster detected",
    "Dominated by small creators — barrier to entry is low"
  ],
  "computedAt": "2024-01-15T10:30:00Z"
}
```

---

### 5. React Query Hook

**File:** `/features/insights/hooks/useInsights.ts`

Create and export `useInsights(keyword: string | null)` using React Query (`useQuery`).

Requirements:
- Only fetch when `keyword` is non-null and non-empty
- Query key: `['insights', keyword]`
- Stale time: 5 minutes (data doesn't need to refresh constantly)
- Return `{ data, isLoading, isError, error }` — typed against `InsightsResponse`
- Handle and surface error state cleanly

---

### 6. UI Components

#### Opportunity Score Panel

**File:** `/features/insights/components/OpportunityPanel.tsx`

Props: `{ data: InsightsResponse, isLoading: boolean }`

Must include:
- Large centered opportunity score number (animated count-up on load)
- Verdict badge with color coding:
  - LOW → red
  - MEDIUM → amber
  - HIGH → blue
  - GOLDMINE → emerald with a subtle glow/shimmer effect
- Three horizontal progress bars labeled Demand, Competition, Saturation — each animates in on load
- Insights bullet list (from `data.insights`) with a subtle icon per bullet
- Skeleton loading state that matches the layout exactly

#### Market Snapshot Cards

**File:** `/features/insights/components/MarketSnapshotCards.tsx`

Props: `{ data: InsightsResponse, isLoading: boolean }`

Render 3–4 compact stat cards in a responsive grid. Each card shows:
- An icon
- A label
- A value or short phrase derived from the signals data

Example cards:
- "Trend Velocity" → value from `trend.velocity`
- "Avg Video Views" → formatted number from `creator.avgViews`
- "Small Creator Share" → `creator.smallCreatorRatio`%
- "Rising Queries" → `trend.risingQueriesCount` detected

Include skeleton loading states.

---

### 7. Updated Trends Page

**File:** `app/trends/page.tsx`

Integrate the new components into the existing Trends Discovery page:

- Add a keyword search input at the top of the page (controlled input, debounced 500ms before triggering fetch)
- Below the search, render `<OpportunityPanel>` and `<MarketSnapshotCards>` side by side on desktop, stacked on mobile
- Show skeleton states while `useInsights` is loading
- Show a clear empty state with a prompt ("Enter a keyword to analyze its opportunity") when no keyword has been entered yet
- Show an error state if the API call fails
- Do not remove any existing page content — add the new section above or below it

---

## DESIGN REQUIREMENTS

- **Dark-mode-first** throughout — all components must look correct on dark backgrounds
- **Premium analytics aesthetic** — think Linear, Vercel dashboard, or Raycast
- Use **shadcn/ui** components wherever appropriate (Card, Badge, Progress, Skeleton, Input)
- Animations must use **Tailwind CSS transitions** or **Framer Motion** — no raw CSS keyframes
- All components must be **fully responsive** (mobile, tablet, desktop)
- Typography: use size hierarchy to communicate importance — score number should be the visual anchor

---

## CONSTRAINTS

- Do NOT use any paid third-party services or APIs
- Keep all integrations compatible with free API tiers
- No new backend database schema changes in this step
- All new code must be in TypeScript with proper types — no `any`
- All components must be modular and reusable
- Do not duplicate logic — scoring functions live only in `scoring.ts`

---

## WHAT NOT TO BUILD IN THIS STEP

- Do not build user authentication flows
- Do not build saved searches or history features
- Do not build comparison between multiple keywords
- Do not build email alerts or notifications
- Do not build any monetization or paywall logic

---

## SUCCESS CRITERIA

Given keyword input `"home workout"`, the full flow should:

1. Trigger a fetch to `/api/insights?keyword=home+workout`
2. Return a structured `InsightsResponse` within ~600ms (simulated)
3. Render the `OpportunityPanel` with a score, verdict badge, and three animated bars
4. Render `MarketSnapshotCards` with 3–4 real signal values
5. Display 3–5 insight bullets relevant to the keyword's data profile
6. Show skeleton states during loading with no layout shift
7. Gracefully handle errors without crashing

---

## DELIVERY ORDER

Produce the following in this exact order so each piece builds on the last:

1. `/features/insights/types.ts`
2. `/features/insights/scoring.ts`
3. `/features/insights/services/generateInsights.ts`
4. `/app/api/insights/route.ts`
5. `/features/insights/hooks/useInsights.ts`
6. `/features/insights/components/OpportunityPanel.tsx`
7. `/features/insights/components/MarketSnapshotCards.tsx`
8. Updated `app/trends/page.tsx`

After all files, provide a brief explanation of any assumptions made and suggestions for when real API data replaces the simulated data.

---
